<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fish Adventure: Big Mine Stun Only - By Chayanan</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #e0f7fa; font-family: 'Tahoma', sans-serif; overflow: hidden; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; max-width: 800px; max-height: 600px; overflow: hidden; box-shadow: 0 0 50px rgba(0,0,0,0.3); border: 2px solid #fff; }
        canvas { background: linear-gradient(#4fc3f7, #01579b); display: block; width: 100%; height: 100%; }
        
        #status-alert { 
            position: absolute; left: 50%; transform: translateX(-50%); 
            color: #ffeb3b; font-weight: bold; text-shadow: 2px 2px #000; 
            z-index: 5; text-align: center; pointer-events: none; width: 90%; line-height: 1.2;
        }

        @media (max-width: 799px) {
            #status-alert { top: 55px; font-size: 18px; }
            #score-display { font-size: 18px !important; }
        }
        @media (min-width: 800px) {
            #status-alert { top: 20px; font-size: 24px; }
        }

        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0, 0, 0, 0.85); color: white; z-index: 10; text-align: center; padding: 20px; box-sizing: border-box; }
        .hidden { display: none !important; }
        .menu-btn { padding: 12px 30px; margin: 8px; font-size: 18px; cursor: pointer; border: none; border-radius: 50px; background: #ffeb3b; color: #01579b; font-weight: bold; box-shadow: 0 5px #fbc02d; }
        
        .hp-bar-container { position: absolute; top: 15px; right: 15px; width: 120px; height: 20px; background: #333; border-radius: 15px; border: 2px solid white; overflow: hidden; z-index: 6; }
        #hp-fill { width: 100%; height: 100%; background: #4caf50; transition: 0.1s; }
        #score-display { position: absolute; top: 15px; left: 15px; color: white; font-weight: bold; font-size: 24px; text-shadow: 2px 2px #0277bd; z-index: 6; }
        
        #boss-ui { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 80%; height: 12px; background: #333; border: 2px solid white; border-radius: 10px; display: none; }
        #boss-hp-fill { width: 100%; height: 100%; background: #ff1744; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="score-display">‡πÅ‡∏ï‡πâ‡∏°: 0</div>
    <div id="status-alert">‡∏™‡∏∞‡∏™‡∏°‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö 5,000!</div>
    <div class="hp-bar-container"><div id="hp-fill"></div></div>
    <div id="boss-ui"><div id="boss-hp-fill"></div></div>

    <div id="main-menu" class="overlay">
        <h1>FISH ADVENTURE</h1>
        <p>‡∏™‡∏∞‡∏™‡∏°‡πÅ‡∏ï‡πâ‡∏°‡∏ñ‡∏∂‡∏á 5,000 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏π‡πâ‡∏ö‡∏≠‡∏™!</p>
        <button class="menu-btn" onclick="startGame()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</button>
        <button class="menu-btn" onclick="showCredits()">‡∏ú‡∏π‡πâ‡∏à‡∏±‡∏î‡∏ó‡∏≥</button>
    </div>

    <div id="credits-menu" class="overlay hidden">
        <h2>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏à‡∏±‡∏î‡∏ó‡∏≥</h2>
        <p>‡∏î.‡∏ä.‡∏ä‡∏ç‡∏≤‡∏ô‡∏±‡∏ô‡∏ï‡πå ‡πÄ‡∏î‡∏ä‡∏ß‡∏á‡∏©‡∏≤ ‡∏°.2/4 ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 1</p>
        <button class="menu-btn" onclick="showMainMenu()">‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</button>
    </div>

    <div id="game-over" class="overlay hidden">
        <h2 style="font-size: 32px; color: #ff5252;">GAME OVER</h2>
        <p id="final-score" style="font-size: 20px; margin-bottom: 20px;"></p>
        <button class="menu-btn" onclick="startGame()">‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
        <button class="menu-btn" onclick="showMainMenu()">‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hpFill = document.getElementById('hp-fill');
    const bossUi = document.getElementById('boss-ui');
    const bossHpFill = document.getElementById('boss-hp-fill');
    const scoreDisplay = document.getElementById('score-display');
    const statusAlert = document.getElementById('status-alert');
    
    let gameRunning = false, score = 0, hp = 100, items = [], bubbles = [], effects = [], lastHungerUpdate = 0;
    let poisonTimer = 0, bossDefeated = false;
    
    const player = { x: 400, y: 300, targetX: 400, targetY: 300, facing: 1 };
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏î‡∏ö‡∏≠‡∏™‡πÄ‡∏õ‡πá‡∏ô 10000
    const boss = { 
        active: false, x: 400, y: 800, hp: 10000, maxHp: 10000, 
        slowTimer: 0, mineCount: 0 
    };

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(freq, type, duration, vol=0.08) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }

    const updateInput = (e) => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const rect = canvas.getBoundingClientRect();
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
        player.targetX = (clientX - rect.left) * (canvas.width / rect.width);
        player.targetY = (clientY - rect.top) * (canvas.height / rect.height);
    };
    
    canvas.addEventListener('mousemove', updateInput);
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); updateInput(e); }, { passive: false });
    canvas.addEventListener('mousedown', updateInput);

    function startGame() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden'));
        gameRunning = true; score = 0; hp = 100; items = []; effects = []; poisonTimer = 0;
        boss.active = false; boss.hp = 10000; boss.y = 800; bossDefeated = false; 
        boss.slowTimer = 0; boss.mineCount = 0;
        bossUi.style.display = 'none';
        player.x = 400; player.y = 300;
        lastHungerUpdate = Date.now();
        updateHPUI();
        scoreDisplay.innerText = `‡πÅ‡∏ï‡πâ‡∏°: 0`;
        requestAnimationFrame(animate);
    }

    function showMainMenu() { document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden')); document.getElementById('main-menu').classList.remove('hidden'); gameRunning = false; }
    function showCredits() { document.getElementById('main-menu').classList.add('hidden'); document.getElementById('credits-menu').classList.remove('hidden'); }

    function updateHPUI() {
        hpFill.style.width = hp + '%';
        hpFill.style.background = poisonTimer > 0 ? "#ea80fc" : (hp > 60 ? '#4caf50' : (hp > 30 ? '#ffeb3b' : '#ff5252'));
        if (hp <= 0 && gameRunning) { gameOver(); }
    }

    function gameOver() { gameRunning = false; document.getElementById('game-over').classList.remove('hidden'); document.getElementById('final-score').innerText = `‡πÅ‡∏ï‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠: ${score}`; }

    function drawFish(x, y, color = '#ff9800', sizeScale = 1, facing = 1) {
        ctx.save(); ctx.translate(x, y); if (facing === -1) ctx.scale(-1, 1);
        ctx.fillStyle = (poisonTimer > 0 && color === '#ff9800') ? '#ea80fc' : color;
        ctx.beginPath(); ctx.ellipse(0, 0, 30*sizeScale, 20*sizeScale, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-25*sizeScale, 0); ctx.lineTo(-45*sizeScale, -15*sizeScale); ctx.lineTo(-45*sizeScale, 15*sizeScale); ctx.closePath(); ctx.fill();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(15*sizeScale, -5*sizeScale, 5*sizeScale, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(17*sizeScale, -5*sizeScale, 2*sizeScale, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    function drawJellyfish(x, y) {
        ctx.save(); let move = Math.sin(Date.now() * 0.005) * 8;
        ctx.fillStyle = 'rgba(234, 128, 252, 0.8)';
        ctx.beginPath(); ctx.arc(x, y + move, 20, Math.PI, 0); ctx.fill();
        ctx.strokeStyle = 'rgba(234, 128, 252, 0.6)'; ctx.lineWidth = 3;
        for(let i=-15; i<=15; i+=10) {
            let tentacleMove = Math.sin(Date.now() * 0.01 + i) * 10;
            ctx.beginPath(); ctx.moveTo(x+i, y+move);
            ctx.quadraticCurveTo(x+i+tentacleMove, y+move+20, x+i, y+move+40); ctx.stroke();
        }
        ctx.restore();
    }

    function drawMine(x, y, radius, isBig = false) {
        ctx.save();
        ctx.fillStyle = isBig ? '#111' : '#333';
        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = ctx.fillStyle; ctx.lineWidth = 4;
        for(let a=0; a<Math.PI*2; a+=Math.PI/4) {
            ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a)*(radius+5), y+Math.sin(a)*(radius+5)); ctx.stroke();
        }
        ctx.fillStyle = (Math.floor(Date.now()/250) % 2 === 0) ? 'red' : '#300';
        ctx.beginPath(); ctx.arc(x, y, radius/3, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    function drawBoss() {
        if (!boss.active) return;
        ctx.save();
        if (boss.slowTimer > 0) ctx.filter = 'hue-rotate(180deg) brightness(1.2) grayscale(0.5)';
        
        ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 15;
        for(let i=0; i<3; i++) {
            let legMove = (boss.slowTimer > 0) ? 0 : Math.sin(Date.now() * 0.01 + i) * 25;
            [-1, 1].forEach(side => {
                ctx.beginPath(); ctx.moveTo(boss.x + (side * 120), boss.y + 40 + (i * 25));
                ctx.lineTo(boss.x + (side * 240) + legMove, boss.y + 120 + (i * 25)); ctx.stroke();
            });
        }

        let armSwing = (boss.slowTimer > 0) ? 0.3 : Math.sin(Date.now() * 0.003) * 0.5;
        let pincerOpen = (boss.slowTimer > 0) ? 0.2 : Math.abs(Math.sin(Date.now() * 0.005)) * 0.7;
        [-1, 1].forEach(side => {
            ctx.save(); ctx.translate(boss.x + (side * 140), boss.y - 20); ctx.scale(side, 1); ctx.rotate(armSwing);
            ctx.strokeStyle = '#b71c1c'; ctx.lineWidth = 25; ctx.beginPath(); ctx.moveTo(0, 0); 
            ctx.quadraticCurveTo(80, -80, 160, -140); ctx.stroke();
            ctx.save(); ctx.translate(160, -140); ctx.rotate(-pincerOpen);
            ctx.fillStyle = '#d32f2f'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(60, -100, 140, -60); ctx.quadraticCurveTo(80, 0, 0, 0); ctx.fill(); ctx.restore();
            ctx.save(); ctx.translate(160, -140); ctx.rotate(pincerOpen * 0.8);
            ctx.fillStyle = '#b71c1c'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(60, 80, 120, 20); ctx.quadraticCurveTo(60, 0, 0, 0); ctx.fill(); ctx.restore();
            ctx.restore();
        });

        ctx.fillStyle = '#b71c1c'; ctx.beginPath(); ctx.ellipse(boss.x, boss.y, 220, 140, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(boss.x-80, boss.y-70, 40, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(boss.x-80, boss.y-80, 18, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(boss.x+80, boss.y-70, 40, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(boss.x+80, boss.y-80, 18, 0, Math.PI*2); ctx.fill();
        
        if (boss.slowTimer <= 0) {
            ctx.fillStyle = "white"; ctx.font = "bold 20px Tahoma"; ctx.textAlign = "center";
            ctx.fillText(`‡∏™‡∏∞‡∏™‡∏°‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏¢‡∏±‡∏Å‡∏©‡πå: ${boss.mineCount}/3`, boss.x, boss.y - 160);
        }
        ctx.restore();
    }

    function animate() {
        if (!gameRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let now = Date.now();
        if (now - lastHungerUpdate > 1000) { hp -= 3; updateHPUI(); lastHungerUpdate = now; }
        if (poisonTimer > 0) { hp -= 0.5; poisonTimer--; updateHPUI(); }

        player.x += (player.targetX - player.x) * 0.12;
        player.y += (player.targetY - player.y) * 0.12;
        player.facing = (player.targetX - player.x) > 0 ? 1 : -1;

        if (Math.random() < 0.1) bubbles.push({x: Math.random()*800, y: 610, s: Math.random()*5+2, sp: Math.random()*2+1});
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        bubbles.forEach((b, i) => { ctx.beginPath(); ctx.arc(b.x, b.y, b.s, 0, Math.PI*2); ctx.fill(); b.y -= b.sp; if(b.y < -10) bubbles.splice(i, 1); });

        if (boss.active) {
            statusAlert.innerText = boss.slowTimer > 0 ? "‚ö° ‡∏™‡∏ï‡∏±‡πä‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≠‡∏°‡πÇ‡∏ö‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏¢‡∏±‡∏Å‡∏©‡πå!" : `ü¶Ä ‡∏•‡πà‡∏≠‡∏ö‡∏≠‡∏™‡πÇ‡∏î‡∏ô‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏¢‡∏±‡∏Å‡∏©‡πå‡∏Ñ‡∏£‡∏ö 3 ‡∏•‡∏π‡∏Å! (${boss.mineCount}/3)`;
            statusAlert.style.color = boss.slowTimer > 0 ? "#00e5ff" : "#ff1744";
        } else if (score >= 2000) {
            statusAlert.innerText = "üëæ ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÅ‡∏°‡∏á‡∏Å‡∏∞‡∏û‡∏£‡∏∏‡∏ô‡∏û‡∏¥‡∏©!";
            statusAlert.style.color = "#ea80fc";
        } else if (score >= 1000) {
            statusAlert.innerText = "üí£ ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏ó‡∏∏‡πà‡∏ô‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏¢‡∏±‡∏Å‡∏©‡πå!";
            statusAlert.style.color = "#ff5252";
        } else if (score >= 500) {
            statusAlert.innerText = "‚ö†Ô∏è ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏ó‡∏∏‡πà‡∏ô‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡πÄ‡∏•‡πá‡∏Å‡πÅ‡∏•‡∏∞‡∏Ç‡∏¢‡∏∞!";
            statusAlert.style.color = "#ffffff";
        } else {
            statusAlert.innerText = "‡∏™‡∏∞‡∏™‡∏°‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏õ‡∏™‡∏π‡πâ‡∏ö‡∏≠‡∏™!";
            statusAlert.style.color = "#ffeb3b";
        }

        if (Math.random() < 0.12) {
            let r = Math.random(); let type = 'food';
            if (r < 0.2) type = 'trash';
            else if (r < 0.3) type = 'worm';
            else if (r < 0.4) type = 'small_fish';
            else if (r < 0.7) {
                if (score >= 2000) {
                    let rand = Math.random();
                    if (rand < 0.35) type = 'jellyfish';
                    else if (rand < 0.7) type = 'big_mine';
                    else type = 'mine';
                } else if (score >= 1000) { type = Math.random() < 0.6 ? 'big_mine' : 'mine';
                } else if (score >= 500) { type = 'mine';
                } else type = 'trash';
            }
            items.push({ x: Math.random()*740+30, y: -50, type, speed: (Math.random()*2+3) });
        }

        if (boss.slowTimer > 0) boss.slowTimer--;
        if (score >= 5000 && !boss.active && !bossDefeated) { boss.active = true; bossUi.style.display = 'block'; }

        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i]; item.y += item.speed;
            if (item.type === 'food') { ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(item.x, item.y, 8, 0, Math.PI*2); ctx.fill(); }
            else if (item.type === 'worm') { ctx.fillStyle = '#ff80ab'; ctx.fillRect(item.x-15, item.y-5, 30, 10); }
            else if (item.type === 'trash') { ctx.fillStyle = '#9e9e9e'; ctx.fillRect(item.x-12, item.y-12, 24, 24); }
            else if (item.type === 'mine') { drawMine(item.x, item.y, 15, false); }
            else if (item.type === 'big_mine') { drawMine(item.x, item.y, 30, true); }
            else if (item.type === 'jellyfish') { drawJellyfish(item.x, item.y); }
            else if (item.type === 'small_fish') { drawFish(item.x, item.y, '#00e5ff', 0.6, 1); }

            let d = Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2);
            if (d < 40) {
                if (item.type === 'food') { score += 10; hp = Math.min(100, hp + 5); playSound(600, 'sine', 0.1); }
                else if (item.type === 'worm') { score += 25; hp = Math.min(100, hp + 20); playSound(800, 'sine', 0.15); }
                else if (item.type === 'small_fish') { score += 100; hp = Math.min(100, hp + 45); playSound(1100, 'sine', 0.2); }
                else if (item.type === 'trash') { hp -= 15; playSound(200, 'sawtooth', 0.2); }
                else if (item.type === 'mine') { hp -= 35; effects.push({x: item.x, y: item.y, r: 20, opacity: 1}); playSound(100, 'sawtooth', 0.3); }
                else if (item.type === 'big_mine') { hp -= 60; effects.push({x: item.x, y: item.y, r: 40, opacity: 1}); playSound(80, 'sawtooth', 0.4); }
                else if (item.type === 'jellyfish') { poisonTimer = 200; playSound(400, 'triangle', 0.4); }
                items.splice(i, 1); scoreDisplay.innerText = `‡πÅ‡∏ï‡πâ‡∏°: ${score}`; updateHPUI(); continue;
            }

            if (boss.active && (item.type === 'mine' || item.type === 'big_mine')) {
                if (Math.sqrt((boss.x - item.x)**2 + (boss.y - item.y)**2) < 200) {
                    boss.hp -= (item.type === 'big_mine' ? 350 : 120);
                    
                    // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏™‡∏ï‡∏±‡πä‡∏ô: ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î‡∏¢‡∏±‡∏Å‡∏©‡πå (big_mine) ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
                    if (boss.slowTimer <= 0 && item.type === 'big_mine') {
                        boss.mineCount++;
                        if (boss.mineCount >= 3) { boss.slowTimer = 180; boss.mineCount = 0; }
                    }
                    
                    effects.push({x: item.x, y: item.y, r: 60, opacity: 1});
                    playSound(60, 'sawtooth', 0.5, 0.2);
                    bossHpFill.style.width = (boss.hp / 10000 * 100) + '%';
                    items.splice(i, 1);
                    if (boss.hp <= 0) { score += 10000; boss.active = false; bossDefeated = true; bossUi.style.display='none'; }
                }
            }
            if (item.y > 650) items.splice(i, 1);
        }

        drawFish(player.x, player.y, '#ff9800', 1, player.facing);
        if (boss.active) {
            if (boss.slowTimer > 0) {
                let dx = boss.x - player.x;
                let dy = boss.y - player.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let knockSpeed = 1.2; 
                boss.x += (dx / dist) * knockSpeed;
                boss.y += (dy / dist) * knockSpeed;
                if (boss.x < 50) boss.x = 50; if (boss.x > 750) boss.x = 750;
                if (boss.y < 50) boss.y = 50; if (boss.y > 550) boss.y = 550;
            } else {
                let followSpeed = 0.001; 
                boss.x += (player.x - boss.x) * followSpeed; 
                boss.y += (player.y - 180 - boss.y) * followSpeed;
                if (boss.y < 50) boss.y = 50;
            }
            
            if (Math.sqrt((boss.x-player.x)**2+(boss.y-player.y)**2) < 220 && boss.slowTimer <= 0) { 
                hp -= 0.7; updateHPUI(); 
            }
            drawBoss();
        }

        effects.forEach((eff, i) => {
            ctx.beginPath(); ctx.strokeStyle = `rgba(255,100,0,${eff.opacity})`; ctx.lineWidth=4;
            ctx.arc(eff.x, eff.y, eff.r, 0, Math.PI*2); ctx.stroke();
            eff.r += 4; eff.opacity -= 0.05; if (eff.opacity <= 0) effects.splice(i, 1);
        });
        requestAnimationFrame(animate);
    }
</script>
</body>
</html>
